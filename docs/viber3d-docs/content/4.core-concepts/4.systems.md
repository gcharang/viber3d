---
title: Systems in Viber3D
description: Systems are functions that process entities each frame (or on events), updating trait data.
---

## Creating Systems

```ts
function movementSystem(world: World) {
  const { delta } = world.get(Time)!
  world.query(Transform, Movement).updateEach(([transform, movement]) => {
    transform.position.add(movement.velocity.clone().multiplyScalar(delta))
  })
}
```

## System Types

1. **Update Systems** run every frame:
   ```ts
   function healthRegenSystem(world: World) {
     const { delta } = world.get(Time)!
     world.query(Health, Regeneration).updateEach(([health, regen]) => {
       health.amount = Math.min(health.max, health.amount + regen.rate * delta)
     })
   }
   ```
2. **Event Systems** respond to specific events.  
3. **Cleanup Systems** remove dead entities, etc.

## System Organization

Usually, you create a file per system in `src/systems/`, then register them in your `gameloop.ts`:

```ts
export function GameLoop() {
  useFrame(() => {
    movementSystem(world)
    collisionSystem(world)
    ...
  })
}
```

## Best Practices

- Single responsibility per system  
- Keep them short and testable  
- Cache queries for performance

## Advanced Patterns

- **System Scheduling**: run certain systems only in certain game states.  
- **Event Bus**: use `world.emit('eventName', payload)` to decouple systems.  
- **Debug Systems**: draw debug info, track performance, etc.

## Testing Systems

```ts
describe('movementSystem', () => {
  it('updates position based on velocity', () => {
    const e = world.spawn(Transform(), Movement({ velocity: new Vector3(1, 0, 0) }))
    movementSystem(world)
    expect(e.get(Transform).position.x).toBeGreaterThan(0)
  })
})