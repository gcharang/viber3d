# Understanding Traits

Traits (also known as Components in other ECS implementations) are the data containers that define the properties and state of entities in Viber3D.

## Defining Traits

Traits are created using the `trait` function:

```typescript
import { trait } from 'koota';
import * as THREE from 'three';

// Simple trait
const Health = trait({
  value: 100,
  max: 100
});

// Complex trait with Vector3
const Transform = trait({
  position: () => new THREE.Vector3(),
  rotation: () => new THREE.Euler(),
  scale: () => new THREE.Vector3(1, 1, 1)
});

// Tag trait (no data)
const IsPlayer = trait({});
```

## Trait Types

### 1. Data Traits
Store entity state and properties:

```typescript
const Movement = trait({
  velocity: () => new THREE.Vector3(),
  speed: 5,
  acceleration: 1,
  damping: 0.95
});
```

### 2. Tag Traits
Mark entities for specific behavior:

```typescript
const IsEnemy = trait({});
const IsProjectile = trait({});
const IsDamageable = trait({});
```

### 3. Reference Traits
Store relationships between entities:

```typescript
const Target = trait({
  entity: null as Entity | null,
  lastSeen: 0
});
```

## Working with Traits

### Initialization

```typescript
// With default values
world.spawn(Health());

// With custom values
world.spawn(Health({ value: 50, max: 75 }));

// With computed values
world.spawn(Transform({
  position: new THREE.Vector3(0, 10, 0)
}));
```

### Accessing Traits

```typescript
// In systems
function healthSystem(world: World) {
  world.query(Health).each(([health]) => {
    // Access trait properties
    const currentHealth = health.value;
    const maxHealth = health.max;
  });
}

// In components
function HealthBar({ entity }: { entity: Entity }) {
  const health = useTraitValue(entity, Health);
  return <div>{health.value} / {health.max}</div>;
}
```

## Best Practices

1. **Keep Traits Focused**
   - One responsibility per trait
   - Split complex traits into smaller ones
   - Use composition for complex behaviors

2. **Type Safety**
   ```typescript
   // Use TypeScript interfaces
   interface HealthData {
     value: number;
     max: number;
   }
   
   const Health = trait<HealthData>({
     value: 100,
     max: 100
   });
   ```

3. **Initialization**
   - Use factory functions for complex initialization
   - Provide sensible defaults
   - Validate trait data

4. **Memory Management**
   - Clean up resources in systems
   - Use value types when possible
   - Be careful with object references

## Common Trait Patterns

### 1. State Machines
```typescript
const AIState = trait({
  current: 'idle' as 'idle' | 'patrol' | 'chase' | 'attack',
  timeInState: 0
});
```

### 2. Timers and Cooldowns
```typescript
const Cooldown = trait({
  duration: 1000,
  lastUsed: 0,
  isReady: true
});
```

### 3. Resource Pools
```typescript
const ResourcePool = trait({
  current: 100,
  max: 100,
  regenRate: 1,
  lastRegen: 0
});
```

## Debugging Traits

```typescript
const Debug = trait({
  enabled: false,
  label: '',
  color: 0xffffff
});

// Add to entities during development
if (isDev) {
  world.spawn(
    Transform(),
    Debug({ enabled: true, label: 'Player' })
  );
}
``` 