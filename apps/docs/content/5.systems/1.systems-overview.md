# Systems Overview

This page provides a comprehensive overview of the built-in systems in Viber3D and their roles in the game loop.

## Core System Types

### 1. Time System
Manages game time and delta updates:

```typescript
import { World } from 'koota';
import { Time } from '../traits';

export function timeSystem(world: World) {
  const time = world.get(Time)!;
  const now = performance.now();
  time.delta = (now - time.last) / 1000;
  time.last = now;
  time.elapsed += time.delta;
}
```

### 2. Input System
Handles keyboard, mouse, and gamepad input:

```typescript
import { Input } from '../traits';

export function inputSystem(world: World) {
  const input = world.get(Input)!;
  
  // Update keyboard state
  input.forward = keys.has('w') || keys.has('ArrowUp');
  input.backward = keys.has('s') || keys.has('ArrowDown');
  input.left = keys.has('a') || keys.has('ArrowLeft');
  input.right = keys.has('d') || keys.has('ArrowRight');
  
  // Update mouse state
  input.mousePosition.copy(mousePosition);
  input.mousePressed = mouseButtons.has(0);
}
```

### 3. Physics Systems

#### Movement System
```typescript
export function movementSystem(world: World) {
  const { delta } = world.get(Time)!;
  
  world.query(Transform, Movement).updateEach(([transform, movement]) => {
    // Apply forces
    movement.velocity.add(
      movement.force.multiplyScalar(delta)
    );
    
    // Apply damping
    movement.velocity.multiplyScalar(movement.damping);
    
    // Update position
    transform.position.add(
      movement.velocity.clone().multiplyScalar(delta)
    );
    
    // Reset forces
    movement.force.set(0, 0, 0);
  });
}
```

#### Collision System
```typescript
export function collisionSystem(world: World) {
  const colliders = world.query(Collider, Transform).collect();
  
  for (let i = 0; i < colliders.length; i++) {
    const [colliderA, transformA] = colliders[i];
    
    for (let j = i + 1; j < colliders.length; j++) {
      const [colliderB, transformB] = colliders[j];
      
      if (checkCollision(transformA, transformB, colliderA, colliderB)) {
        world.emit('collision', {
          entityA: colliderA.entity,
          entityB: colliderB.entity
        });
      }
    }
  }
}
```

### 4. Game Logic Systems

#### Combat System
```typescript
export function combatSystem(world: World) {
  // Process damage
  world.query(Health, Damage).updateEach(([health, damage]) => {
    health.value -= damage.amount;
    if (health.value <= 0) {
      world.emit('death', { entity: health.entity });
    }
  });
  
  // Clear processed damage
  world.query(Damage).removeAll();
}
```

#### AI System
```typescript
export function aiSystem(world: World) {
  const player = world.queryFirst(IsPlayer, Transform);
  if (!player) return;
  
  world.query(AI, Transform).updateEach(([ai, transform]) => {
    switch (ai.state) {
      case 'idle':
        // Check for player in range
        break;
      case 'chase':
        // Move toward player
        break;
      case 'attack':
        // Attack if in range
        break;
    }
  });
}
```

### 5. Visual Systems

#### Camera System
```typescript
export function cameraSystem(world: World) {
  const camera = world.queryFirst(IsCamera, Transform);
  const target = world.queryFirst(IsPlayer, Transform);
  
  if (!camera || !target) return;
  
  // Smooth follow
  camera.transform.position.lerp(
    target.transform.position.clone().add(cameraOffset),
    0.1
  );
}
```

#### Effect System
```typescript
export function effectSystem(world: World) {
  world.query(ParticleEmitter).updateEach(([emitter]) => {
    if (emitter.shouldEmit) {
      spawnParticles(world, emitter);
    }
  });
  
  // Update existing particles
  world.query(Particle).updateEach(([particle]) => {
    updateParticle(particle);
  });
}
```

## System Execution Order

The order of system execution is crucial for game behavior:

```typescript
export const systemOrder = [
  // Core updates
  timeSystem,
  inputSystem,
  
  // Game logic
  aiSystem,
  weaponSystem,
  
  // Physics
  movementSystem,
  collisionSystem,
  
  // Combat
  combatSystem,
  damageSystem,
  
  // Visual
  cameraSystem,
  effectSystem,
  
  // Cleanup
  cleanupSystem
];
```

## System Communication

Systems can communicate through:

1. **Direct Trait Updates**
```typescript
// Update health directly
health.value -= damage.amount;
```

2. **Events**
```typescript
// Emit event
world.emit('playerHit', { damage: 10 });

// Listen for event
world.on('playerHit', ({ damage }) => {
  // Handle hit
});
```

3. **Shared Resources**
```typescript
const gameState = world.get(GameState)!;
gameState.score += 100;
```

## Performance Considerations

1. **Query Caching**
```typescript
// Cache query for better performance
const query = world.query(Transform, Movement);
for (let i = 0; i < iterations; i++) {
  query.updateEach(/* ... */);
}
```

2. **Batch Processing**
```typescript
// Process entities in batches
const entities = world.query(Bullet).collect();
for (let i = 0; i < entities.length; i += BATCH_SIZE) {
  processBatch(entities.slice(i, i + BATCH_SIZE));
}
```

3. **System Scheduling**
```typescript
// Enable/disable systems based on game state
if (gameState.isPaused) {
  return; // Skip system execution
}
```

## Debug Tools

```typescript
// Debug system for visualizing entity states
export function debugSystem(world: World) {
  if (!isDebugMode) return;
  
  world.query(Debug).each(([debug]) => {
    renderDebugInfo(debug);
  });
}

// Performance monitoring
export function performanceSystem(world: World) {
  const stats = world.get(PerformanceStats)!;
  stats.recordSystemTime('physics', () => {
    physicsSystem(world);
  });
}
``` 