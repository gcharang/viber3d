# Working with Entities

In Viber3D, entities are the fundamental building blocks of your game. They represent any object in your game world, from players and enemies to UI elements and invisible game logic handlers.

## Creating Entities

Entities are created using the `spawn` method:

```typescript
import { World } from 'koota';
import { Transform, Health, IsPlayer } from '../traits';

// Create a player entity
world.spawn(
  Transform({ position: new THREE.Vector3() }),
  Health({ value: 100, max: 100 }),
  IsPlayer()
);
```

## Entity Actions

It's recommended to centralize entity creation in action functions:

```typescript
// actions.ts
export function spawnPlayer(world: World, position: THREE.Vector3) {
  return world.spawn(
    Transform({ position }),
    Health({ value: 100 }),
    Movement({ speed: 5 }),
    IsPlayer()
  );
}
```

## Querying Entities

Find entities with specific traits:

```typescript
// Single entity
const player = world.queryFirst(IsPlayer);

// Multiple entities
const enemies = world.query(IsEnemy, Health);

// With filtering
const lowHealthEnemies = world.query(IsEnemy, Health)
  .filter(([_, health]) => health.value < 50);
```

## Updating Entities

Modify entity traits through systems:

```typescript
function damageSystem(world: World) {
  world.query(Health).updateEach(([health]) => {
    if (health.value <= 0) {
      // Handle death
    }
  });
}
```

## Removing Entities

Entities can be removed in several ways:

```typescript
// Remove by reference
world.remove(entity);

// Remove in a query
world.query(Health).removeIf(([health]) => health.value <= 0);

// Remove all with a trait
world.removeAll(IsTemporary);
```

## Entity Lifecycle

1. **Creation**
   - Spawn with initial traits
   - Set up initial state
   - Register in relevant systems

2. **Updates**
   - Systems process entity traits
   - Components render entity state
   - Traits can be added/removed

3. **Cleanup**
   - Remove when no longer needed
   - Clean up associated resources
   - Unregister from systems

## Best Practices

1. **Entity Organization**
   - Group related traits together
   - Use descriptive trait names
   - Consider entity relationships

2. **Performance**
   - Reuse entities when possible
   - Batch entity operations
   - Clean up unused entities

3. **Debugging**
   - Add debug traits for development
   - Log entity lifecycle events
   - Monitor entity counts

## Common Patterns

1. **Entity Templates**
```typescript
const enemyTemplate = {
  traits: [
    Transform,
    Health({ value: 50 }),
    IsEnemy
  ]
};

function spawnEnemy(world: World) {
  return world.spawn(...enemyTemplate.traits);
}
```

2. **Entity References**
```typescript
const TargetRef = trait({
  entity: null as Entity | null
});

// Track relationships between entities
world.spawn(
  IsProjectile(),
  TargetRef({ entity: targetEntity })
);
``` 