# Systems in Viber3D

Systems are the logic processors in the ECS architecture. They operate on entities with specific traits, updating their state each frame or in response to events.

## Creating Systems

A system is a function that receives the world instance:

```typescript
import { World } from 'koota';
import { Transform, Movement, Time } from '../traits';

function movementSystem(world: World) {
  const { delta } = world.get(Time)!;
  
  world.query(Transform, Movement).updateEach(([transform, movement]) => {
    transform.position.add(
      movement.velocity.clone().multiplyScalar(delta)
    );
  });
}
```

## System Types

### 1. Update Systems
Run every frame to update entity state:

```typescript
function healthRegenSystem(world: World) {
  const { delta } = world.get(Time)!;
  
  world.query(Health, Regeneration).updateEach(([health, regen]) => {
    health.value = Math.min(
      health.max,
      health.value + regen.rate * delta
    );
  });
}
```

### 2. Event Systems
Respond to specific events or conditions:

```typescript
function collisionSystem(world: World) {
  world.query(Collider, Transform).each(([collider, transform]) => {
    const hits = findCollisions(transform.position, collider.radius);
    if (hits.length) {
      world.emit('collision', { entity: collider.entity, hits });
    }
  });
}
```

### 3. Cleanup Systems
Manage entity lifecycle:

```typescript
function cleanupSystem(world: World) {
  // Remove expired entities
  world.query(Lifetime).removeIf(([lifetime]) => 
    lifetime.elapsed >= lifetime.duration
  );
}
```

## System Organization

### Registration
Register systems in your game loop:

```typescript
// gameloop.ts
export function createGameLoop(world: World) {
  const systems = [
    timeSystem,
    inputSystem,
    movementSystem,
    collisionSystem,
    renderSystem
  ];

  return () => {
    for (const system of systems) {
      system(world);
    }
  };
}
```

### System Dependencies
Order systems based on dependencies:

```typescript
const systemOrder = [
  timeSystem,        // Updates delta time
  inputSystem,       // Processes input
  aiSystem,         // Updates AI decisions
  physicsSystem,    // Updates physics
  collisionSystem,  // Checks collisions
  damageSystem,     // Applies damage
  cleanupSystem,    // Removes dead entities
  renderSystem      // Updates visuals
];
```

## Best Practices

1. **Single Responsibility**
   - Each system should do one thing
   - Split complex systems into smaller ones
   - Keep systems focused and testable

2. **Performance**
   ```typescript
   function optimizedSystem(world: World) {
     // Cache queries for better performance
     const query = world.query(Transform, Movement);
     
     // Batch process entities
     query.updateEach(([transform, movement]) => {
       // Process in batches
     });
   }
   ```

3. **Error Handling**
   ```typescript
   function robustSystem(world: World) {
     try {
       world.query(Health).updateEach(([health]) => {
         // Safe updates
       });
     } catch (error) {
       console.error('System error:', error);
       // Handle or report error
     }
   }
   ```

## Advanced Patterns

### 1. System Configuration
```typescript
interface SystemConfig {
  enabled: boolean;
  priority: number;
  debugLevel: 'none' | 'basic' | 'verbose';
}

function configureableSystem(world: World, config: SystemConfig) {
  if (!config.enabled) return;
  // System logic
}
```

### 2. System Communication
```typescript
// Event-based communication
world.on('damage', ({ target, amount }) => {
  const health = world.get(target, Health);
  if (health) {
    health.value -= amount;
  }
});

// Emit events from systems
function damageSystem(world: World) {
  world.query(Damage).each(([damage]) => {
    world.emit('damage', {
      target: damage.target,
      amount: damage.amount
    });
  });
}
```

### 3. Debug Systems
```typescript
function debugSystem(world: World) {
  if (!isDev) return;
  
  world.query(Debug, Transform).each(([debug, transform]) => {
    drawDebugInfo(debug, transform);
  });
}
```

## Testing Systems

```typescript
describe('movementSystem', () => {
  let world: World;
  
  beforeEach(() => {
    world = new World();
  });
  
  test('updates position based on velocity', () => {
    const entity = world.spawn(
      Transform(),
      Movement({ velocity: new THREE.Vector3(1, 0, 0) })
    );
    
    movementSystem(world);
    
    const transform = world.get(entity, Transform)!;
    expect(transform.position.x).toBeGreaterThan(0);
  });
}); 