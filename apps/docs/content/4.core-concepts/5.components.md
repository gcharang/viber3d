# React Components in Viber3D

Components in Viber3D are React components that render entities and their traits. They bridge the ECS world with Three.js and React's rendering system.

## Basic Component Structure

```typescript
import { useTraitValue } from 'koota-react';
import { useFrame } from '@react-three/fiber';
import { Transform, Model } from '../traits';

function PlayerModel({ entity }: { entity: Entity }) {
  const transform = useTraitValue(entity, Transform);
  const model = useTraitValue(entity, Model);

  return (
    <group position={transform.position}>
      <mesh>
        <boxGeometry />
        <meshStandardMaterial color={model.color} />
      </mesh>
    </group>
  );
}
```

## Hooks and Utilities

### 1. ECS Hooks

```typescript
// Get a single trait
function HealthBar({ entity }: { entity: Entity }) {
  const health = useTraitValue(entity, Health);
  return <div>{health.value} / {health.max}</div>;
}

// Query for entities
function EnemyList() {
  const enemies = useQuery(IsEnemy, Health);
  return (
    <div>
      {enemies.map(([enemy, health]) => (
        <EnemyStatus key={enemy.id} health={health} />
      ))}
    </div>
  );
}

// Watch for changes
function DamageIndicator({ entity }: { entity: Entity }) {
  const health = useTraitWatch(entity, Health);
  return <Effect visible={health.value < 50} />;
}
```

### 2. Three.js Integration

```typescript
function GameEntity({ entity }: { entity: Entity }) {
  const transform = useTraitValue(entity, Transform);
  const ref = useRef<THREE.Group>();

  useFrame(() => {
    if (ref.current) {
      ref.current.position.copy(transform.position);
      ref.current.rotation.copy(transform.rotation);
    }
  });

  return (
    <group ref={ref}>
      <EntityModel entity={entity} />
    </group>
  );
}
```

## Component Types

### 1. Entity Renderers

```typescript
function BulletRenderer({ entity }: { entity: Entity }) {
  const transform = useTraitValue(entity, Transform);
  const bullet = useTraitValue(entity, Bullet);

  return (
    <mesh position={transform.position}>
      <sphereGeometry args={[bullet.radius]} />
      <meshBasicMaterial color={bullet.color} />
    </mesh>
  );
}
```

### 2. UI Components

```typescript
function PlayerHUD() {
  const player = useQueryFirst(IsPlayer);
  if (!player) return null;

  return (
    <div className="hud">
      <HealthBar entity={player} />
      <AmmoCounter entity={player} />
      <Crosshair entity={player} />
    </div>
  );
}
```

### 3. Effect Components

```typescript
function ExplosionEffect({ position }: { position: THREE.Vector3 }) {
  const [particles, setParticles] = useState<Particle[]>([]);
  
  useFrame((_, delta) => {
    // Update particle positions
  });

  return (
    <group position={position}>
      {particles.map((particle, i) => (
        <Particle key={i} {...particle} />
      ))}
    </group>
  );
}
```

## Performance Optimization

### 1. Memoization

```typescript
const MemoizedEntity = memo(function Entity({ entity }: { entity: Entity }) {
  const transform = useTraitValue(entity, Transform);
  return <primitive object={transform} />;
});
```

### 2. Instance Rendering

```typescript
function InstancedEntities() {
  const entities = useQuery(Transform, InstanceData);
  const instanceMatrix = useMemo(() => {
    // Create instance matrices
  }, [entities]);

  return (
    <instancedMesh args={[null, null, entities.length]}>
      <boxGeometry />
      <meshStandardMaterial />
    </instancedMesh>
  );
}
```

### 3. Culling and LOD

```typescript
function AdaptiveEntity({ entity }: { entity: Entity }) {
  const transform = useTraitValue(entity, Transform);
  const distance = useDistanceToCamera(transform.position);

  return (
    <LOD>
      <HighDetailModel visible={distance < 10} />
      <MediumDetailModel visible={distance < 50} />
      <LowDetailModel visible={distance >= 50} />
    </LOD>
  );
}
```

## Best Practices

1. **Component Organization**
   - Group related components
   - Separate UI and 3D components
   - Use composition for complex visuals

2. **State Management**
   - Use ECS for game state
   - React state for UI-only state
   - Minimize component state

3. **Rendering Efficiency**
   - Use instancing for repeated elements
   - Implement proper culling
   - Optimize heavy computations

## Debug Components

```typescript
function DebugView({ enabled = true }) {
  if (!enabled) return null;

  return (
    <>
      <axesHelper />
      <gridHelper />
      <EntityDebugInfo />
    </>
  );
}

function EntityDebugInfo() {
  const debugEntities = useQuery(Debug);
  
  return (
    <group>
      {debugEntities.map(([entity, debug]) => (
        <DebugLabel
          key={entity.id}
          position={entity.get(Transform)?.position}
          label={debug.label}
        />
      ))}
    </group>
  );
} 